(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{307:function(v,_,e){"use strict";e.r(_);var t=e(14),a=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"前端面试总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#前端面试总结"}},[v._v("#")]),v._v(" 前端面试总结")]),v._v(" "),_("h2",{attrs:{id:"面试单位-店匠科技-资深前端"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#面试单位-店匠科技-资深前端"}},[v._v("#")]),v._v(" "),_("code",[v._v("面试单位：")]),v._v(" 店匠科技（资深前端）")]),v._v(" "),_("h3",{attrs:{id:"_1-请做下自我介绍"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-请做下自我介绍"}},[v._v("#")]),v._v(" 1.请做下自我介绍")]),v._v(" "),_("p",[v._v("介绍了自己的工作年限，近期任职的工作内容，熟悉的技术栈，精通的知识点和项目亮点。然后引导面试官关注简历，就感兴趣的点问问题。")]),v._v(" "),_("h3",{attrs:{id:"_2-说下react的底层原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-说下react的底层原理"}},[v._v("#")]),v._v(" 2.说下React的底层原理")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("Virtual DOM（虚拟DOM）：")]),v._v("这是React的核心部分，它是一个轻量级的JavaScript对象，模拟了真实DOM的节点树。当数据发生变化时，React会用新的数据更新Virtual DOM中的节点，然后通过比较新旧节点，计算出需要更新的部分，最后只更新需要更新的部分。这种方式可以避免每次数据变化都重新渲染整个页面，从而提高了性能。")]),v._v(" "),_("li",[_("code",[v._v("协调算法：")]),v._v("React通过协调算法来确定需要更新的节点。这个算法主要包括diff算法和调和算法两个部分。Diff算法将新的Virtual DOM节点与旧的Virtual DOM节点进行比较，找出需要更新的节点，并生成一份更新操作指令。调和算法则将更新操作指令应用到真实DOM节点上，完成DOM的更新。React的协调算法能够非常高效地渲染组件，即使组件树非常大，也可以快速地更新需要更新的部分。")]),v._v(" "),_("li",[_("code",[v._v("ReactDOM：")]),v._v("这是React库的一部分，是将React和真实DOM节点连接起来的重要组件。它将React组件渲染到指定的DOM节点上，并负责处理事件和属性的变化等。")]),v._v(" "),_("li",[_("code",[v._v("组件系统：")]),v._v("React的基础是组件，组件是一种可复用的、可配置的、可定制的UI功能。组件将数据和逻辑封装在一起，可以使用props来传递数据和方法。")]),v._v(" "),_("li",[_("code",[v._v("合成事件：")]),v._v("React使用合成事件来捕获用户的输入，而不是使用传统的DOM事件机制。这样可以减少处理事件的代码量，并提高性能。")])]),v._v(" "),_("h3",{attrs:{id:"_3-react和vue有什么不同"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-react和vue有什么不同"}},[v._v("#")]),v._v(" 3.React和Vue有什么不同?")]),v._v(" "),_("p",[v._v("React和Vue在底层原理上有一些不同之处，主要表现在以下几个方面：")]),v._v(" "),_("ul",[_("li",[_("p",[_("code",[v._v("模板渲染方式：")]),v._v("React使用JSX语法渲染模板，而Vue使用模板语法。JSX是一种在JavaScript中编写HTML的语法，需要通过编译才能在浏览器中运行。而Vue的模板语法则更接近于HTML，可以直接在浏览器中运行。")])]),v._v(" "),_("li",[_("p",[_("code",[v._v("渲染过程：")]),v._v("Vue在渲染过程中会跟踪每个组件的依赖关系，因此在更新组件时，只需要重新渲染有依赖关系的部分，这可以提高渲染效率。而React在更新组件时，会重新渲染整个组件树，这可能会导致不必要的性能开销。")])]),v._v(" "),_("li",[_("p",[_("code",[v._v("数据流：")]),v._v("Vue是响应式的数据双向绑定系统，数据的变化会驱动视图的变化。而React则是单向数据流，数据从父组件流向子组件，只能通过props传递，这使得数据的管理更加清晰和可控。")])]),v._v(" "),_("li",[_("p",[_("code",[v._v("监听数据变化的实现原理：")]),v._v("Vue通过getter/setter以及一些函数的劫持，能精确知道数据变化，从而进行高效的DOM更新。而React默认通过diff算法，将新的数据和老的数据作对比，然后重新渲染，这种方式在数据量大时可能会导致性能问题。")])])]),v._v(" "),_("p",[v._v("此外，React和Vue在框架本质、适用场景等方面也有一些不同。React是一种前端组件化框架，由后端组件化发展而来，更适合构建大型应用和复杂组件。而Vue则是一种轻量级的MVVM框架，由MVC发展而来，更适合开发单页面应用和小型项目。")]),v._v(" "),_("h3",{attrs:{id:"_4-es6新增了哪些新特性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-es6新增了哪些新特性"}},[v._v("#")]),v._v(" 4.ES6新增了哪些新特性？")]),v._v(" "),_("p",[v._v("ES6新增了很多新特性包括：")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("let和const声明变量：")]),v._v("ES6引入了新的关键字let和const来声明变量和常量，它们提供了更好的块级作用域和避免了一些var关键字的问题。")]),v._v(" "),_("li",[_("code",[v._v("箭头函数：")]),v._v("箭头函数提供了一种更简洁的函数语法，同时它还有自己的this值、arguments对象、super关键字和new.target属性。")]),v._v(" "),_("li",[_("code",[v._v("模板字符串：")]),v._v("模板字符串允许在字符串中嵌入表达式，使用反引号（`）来定义模板字符串，可以在其中使用${}来嵌入变量或表达式。")]),v._v(" "),_("li",[_("code",[v._v("解构赋值：")]),v._v("解构赋值允许从数组或对象中提取值，然后将其赋值给变量。这使得从函数返回多个值或处理复杂数据结构变得更加简单。")]),v._v(" "),_("li",[_("code",[v._v("默认参数：")]),v._v("在定义函数时，可以为参数设置默认值，这样在调用函数时如果没有传入该参数，就会使用默认值。")]),v._v(" "),_("li",[_("code",[v._v("扩展运算符：")]),v._v("扩展运算符可以用于展开数组或对象，将它们转换为用逗号分隔的参数序列或属性序列。")]),v._v(" "),_("li",[_("code",[v._v("类和模块：")]),v._v("ES6引入了类和模块的概念，使得面向对象编程和代码组织更加方便。")]),v._v(" "),_("li",[_("code",[v._v("迭代器和生成器：")]),v._v(" 迭代器和生成器提供了一种遍历数据集合的方式，可以方便地处理数组、对象、Map、Set等数据结构。")]),v._v(" "),_("li",[_("code",[v._v("Promise对象：")]),v._v("Promise对象用于处理异步操作，可以避免回调地狱的问题，使异步代码更加易读和易于维护。")]),v._v(" "),_("li",[_("code",[v._v("模块化导入和导出：")]),v._v("ES6提供了模块化的导入和导出语法，使得代码可以更加模块化和可重用。")])]),v._v(" "),_("p",[v._v("此外，ES6还新增了一些其他的特性，如"),_("code",[v._v("Symbol")]),v._v("类型、"),_("code",[v._v("Map")]),v._v("和"),_("code",[v._v("Set")]),v._v("数据结构、"),_("code",[v._v("Proxy")]),v._v("对象、"),_("code",[v._v("Reflect")]),v._v("对象、"),_("code",[v._v("For...of")]),v._v("循环等等。这些新特性使得JavaScript语言更加强大和灵活，可以更好地应对复杂的应用场景。")]),v._v(" "),_("h3",{attrs:{id:"_5-typescript你用到了哪些特殊的用法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-typescript你用到了哪些特殊的用法"}},[v._v("#")]),v._v(" 5.TypeScript你用到了哪些特殊的用法？")]),v._v(" "),_("p",[v._v("TypeScript 是一种基于 JavaScript 的静态类型检查语言，它在 JavaScript 的基础上增加了很多强大的功能。以下是常用到的特殊用法：")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("接口（Interfaces）：")]),v._v("接口在 TypeScript 中被用来定义对象的形状，即对象应该具有哪些属性和方法。这有助于在编码阶段就捕获一些类型错误，提高代码的健壮性。")]),v._v(" "),_("li",[_("code",[v._v("泛型（Generics）：")]),v._v("泛型允许你在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再为其指定类型。这增强了代码的重用性和灵活性。")]),v._v(" "),_("li",[_("code",[v._v("枚举（Enums）：")]),v._v("枚举类型用于定义数值集合，比如一周的天数或者颜色等。它让代码更具可读性，同时也提供了一种类型安全的方式来引用这些值。")]),v._v(" "),_("li",[_("code",[v._v("类型别名（Type Aliases）：")]),v._v("类型别名是给类型起一个新的名字，这在处理复杂类型或者需要多次引用同一类型时非常有用。")]),v._v(" "),_("li",[_("code",[v._v("字符串字面量类型（String Literal Types）：")]),v._v("这允许你指定字符串只能是某几个特定的值之一，增强了代码的类型安全性。")]),v._v(" "),_("li",[_("code",[v._v("联合类型（Union Types）和交叉类型（Intersection Types）：")]),v._v("联合类型表示一个值可以是几种类型之一，而交叉类型则表示一个值必须同时满足多个类型的条件。")]),v._v(" "),_("li",[_("code",[v._v("非空断言运算符（Non-null Assertion Operator）：")]),v._v("在严格空值检查模式下，当你确定一个值不可能是 null 或 undefined 时，可以使用这个运算符来告诉 TypeScript 编译器忽略这个检查。")]),v._v(" "),_("li",[_("code",[v._v("条件类型（Conditional Types）：")]),v._v("这是一种高级的类型操作，允许你根据条件来生成不同的类型。这在实现泛型函数或类型时非常有用。")]),v._v(" "),_("li",[_("code",[v._v("模块（Modules）：")]),v._v("TypeScript 支持 ES6 的模块系统，这使得代码的组织和导入导出更加模块化。")]),v._v(" "),_("li",[_("code",[v._v("装饰器（Decorators）：")]),v._v("装饰器是一种特殊类型的声明，它可以被附加到类声明、方法、属性或参数上。装饰器使用 "),_("code",[v._v("@expression")]),v._v(" 这样的形式，其中 expression 必须计算为一个函数，该函数将在运行时被调用。这在一些高级用法中，如依赖注入、日志记录等场景中非常有用。")])]),v._v(" "),_("p",[v._v("使用这些特殊用法，可编写出更加健壮、可维护性强的代码。")]),v._v(" "),_("h3",{attrs:{id:"_6-浏览器中输入一个有效网址回车后经历哪些过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-浏览器中输入一个有效网址回车后经历哪些过程"}},[v._v("#")]),v._v(" 6.浏览器中输入一个有效网址回车后经历哪些过程？")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("DNS解析：")]),v._v("浏览器首先会检查本地缓存，看是否有这个网址的DNS解析结果。如果本地缓存中没有，浏览器会向DNS服务器发送请求，获取对应的IP地址。这个过程可能涉及到递归查询和迭代查询。")]),v._v(" "),_("li",[_("code",[v._v("建立TCP连接：")]),v._v("浏览器通过获取到的IP地址和目标服务器的端口号，建立一个TCP连接。这个过程中还包含了三次握手的过程，即SYN、SYN-ACK、ACK。")]),v._v(" "),_("li",[_("code",[v._v("发送HTTP请求：")]),v._v("TCP连接建立成功后，浏览器会构建一个HTTP请求报文，包括请求方法、请求头、请求体等信息，并发送给服务器。")]),v._v(" "),_("li",[_("code",[v._v("服务器处理请求并返回HTTP响应：")]),v._v("服务器在接收到请求报文后，会根据请求报文中的信息进行处理，生成相应的响应报文，并返回给客户端。")]),v._v(" "),_("li",[_("code",[v._v("浏览器解析渲染页面：")]),v._v("当浏览器接收到响应报文后，会根据响应头中的Content-Type属性确定响应内容的类型，并进行相应的处理。比如，如果是HTML类型，浏览器就会解析HTML代码，构建DOM树，解析CSS代码，构建渲染树，并进行布局和绘制，最终展示出页面。")]),v._v(" "),_("li",[_("code",[v._v("断开TCP连接：")]),v._v("当页面全部渲染完成后，浏览器会关闭TCP连接，释放资源。")])]),v._v(" "),_("h3",{attrs:{id:"_7-symbol你用过吗-用在哪些地方"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-symbol你用过吗-用在哪些地方"}},[v._v("#")]),v._v(" 7.Symbol你用过吗？用在哪些地方？")]),v._v(" "),_("p",[v._v("是的，我用过ES6中的Symbol，它是一种新的原始数据类型，表示独一无二的值。Symbol的主要用途是定义对象的唯一属性名，这样可以避免属性名的冲突。")]),v._v(" "),_("p",[v._v("在实际应用中，会在以下场景中使用Symbol：")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("定义唯一属性名：")]),v._v("这是Symbol最常见的用途是作为对象的唯一属性名。由于每个Symbol值都是唯一的，因此它们可以用作标识符，以确保不会与其他属性名冲突。这在创建对象或库时特别有用，特别是当你需要确保某些属性或方法的名称是唯一的时。")]),v._v(" "),_("li",[_("code",[v._v("迭代器和生成器：")]),v._v("Symbol.iterator是一个特殊的Symbol值，用于定义对象的迭代器行为。当你希望自定义一个对象的迭代行为时，你可以在你的对象上定义这个Symbol。例如，你可以在一个数组或集合上定义Symbol.iterator，以便使用for...of循环来遍历它。")]),v._v(" "),_("li",[_("code",[v._v("对象属性的私有性和保护：")]),v._v("虽然JavaScript本身不支持真正的私有属性，但你可以使用Symbol来模拟私有属性。由于Symbol的唯一性，你可以将Symbol作为对象的属性名，从而避免外部代码直接访问或修改这些属性。")]),v._v(" "),_("li",[_("code",[v._v("元编程和自定义行为：")]),v._v("通过使用Symbol，你可以定义一些特殊的行为，例如自定义对象的序列化行为（通过定义Symbol.toPrimitive）或自定义对象的比较行为（通过定义Symbol.equals）。")])]),v._v(" "),_("p",[v._v("总的来说，ES6中的Symbol提供了一种强大而灵活的工具，可以用于定义唯一属性名、自定义迭代行为、模拟私有属性以及实现元编程等场景。")]),v._v(" "),_("h3",{attrs:{id:"_8-实例化一个对象有哪些过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-实例化一个对象有哪些过程"}},[v._v("#")]),v._v(" 8.实例化一个对象有哪些过程？")]),v._v(" "),_("p",[v._v("使用 new 关键字来实例化一个类时，发生了以下几个关键步骤：")]),v._v(" "),_("ul",[_("li",[_("p",[_("code",[v._v("创建新对象：")]),v._v("\nJavaScript 运行时系统首先会创建一个新的空对象。这个新对象将作为新实例的基础。")])]),v._v(" "),_("li",[_("p",[_("code",[v._v("设置原型链：")]),v._v("\n新创建的对象的内部链接"),_("code",[v._v("Prototype")]),v._v("会被设置为构造函数的 prototype 对象。这意味着新创建的对象可以访问在构造函数 prototype 上定义的属性和方法。这是实现继承的基础。")])]),v._v(" "),_("li",[_("p",[_("code",[v._v("执行构造函数：")]),v._v("\n构造函数（类定义时的那个函数）会被调用，并传入你提供的参数（如果有的话）。构造函数内部的代码会执行，通常包括初始化新对象的属性。this 关键字在构造函数内部引用的是新创建的对象。")])]),v._v(" "),_("li",[_("p",[_("code",[v._v("返回新对象：")]),v._v("\n如果构造函数中没有显式地返回一个对象，那么 new 表达式的结果就是新创建的对象。如果构造函数返回了一个非原始类型（即对象或函数），那么这个返回值将替代新创建的对象成为 new 表达式的结果。如果构造函数返回了一个原始值（如 undefined、null、数字、字符串或布尔值），那么新创建的对象仍然会被返回。")])])]),v._v(" "),_("h3",{attrs:{id:"_9-普通函数和箭头函数有什么区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_9-普通函数和箭头函数有什么区别"}},[v._v("#")]),v._v(" 9.普通函数和箭头函数有什么区别?")]),v._v(" "),_("p",[v._v("普通函数和箭头函数之间存在以下主要差异：")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("外形与定义方式：")]),v._v("普通函数使用 function 关键字进行定义，如 function functionName(parameters) { ... }。而箭头函数使用 => 符号进行定义，如 (parameters) => { ... }。箭头函数更简洁，没有 function 关键字。")]),v._v(" "),_("li",[_("code",[v._v("this 指向：")]),v._v("普通函数中，this 的值取决于函数的调用方式。它可能指向全局对象、调用该函数的对象或构造函数创建的新对象。而在箭头函数中，this 继承自包围它的函数或全局作用域。这意味着在箭头函数中，this 的值不会因调用方式而改变。")]),v._v(" "),_("li",[_("code",[v._v("构造函数：")]),v._v("普通函数可以作为构造函数使用，通过 new 关键字创建对象实例。而箭头函数不能作为构造函数，不能使用 new 关键字。")]),v._v(" "),_("li",[_("code",[v._v("arguments 对象：")]),v._v("每个普通函数在被调用时都会获得一个 arguments 对象，该对象包含了传递给函数的所有参数。但箭头函数没有 arguments 对象，如果需要访问参数，可以通过剩余参数（rest parameters）来实现。")]),v._v(" "),_("li",[_("code",[v._v("prototype 原型对象：")]),v._v("普通函数具有 prototype 属性，可以为其添加方法，这些方法将被所有实例共享。而箭头函数没有 prototype 属性，因此不能添加共享方法。")]),v._v(" "),_("li",[_("code",[v._v("其他特性：")]),v._v("箭头函数还不能用作 Generator 函数，也就是说，它们不能使用 yield 关键字。此外，箭头函数也没有 super 和 new.target 关键字。")])]),v._v(" "),_("h3",{attrs:{id:"_10-你平时做管理和开发是怎么平衡的-开发主要做些什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_10-你平时做管理和开发是怎么平衡的-开发主要做些什么"}},[v._v("#")]),v._v(" 10.你平时做管理和开发是怎么平衡的？开发主要做些什么？")]),v._v(" "),_("p",[v._v("平衡前端管理和开发工作,主要做了这些方面：")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("明确目标和优先级：")]),v._v("首先，了解你的团队和项目的长期目标是非常重要的。这将帮助你确定哪些任务是优先的，哪些可以稍后处理。")]),v._v(" "),_("li",[_("code",[v._v("制定计划和时间表：")]),v._v("为每个任务分配一个估计的完成时间，并确保你有足够的时间来完成开发任务，同时也要为管理任务留出时间。")]),v._v(" "),_("li",[_("code",[v._v("委派和分工：")]),v._v("作为管理者，你的任务之一是确保工作得到高效完成。这可能意味着将一些开发任务委派给团队成员，以便可以专注于管理工作。")]),v._v(" "),_("li",[_("code",[v._v("保持沟通：")]),v._v("与团队成员保持定期沟通，了解他们的工作进度和可能遇到的挑战。这有助于你更好地调整你的管理策略，并提供必要的支持。")]),v._v(" "),_("li",[_("code",[v._v("使用合适的工具和技术：")]),v._v("利用前端开发工具和技术来提高效率。例如，使用版本控制系统（如Git）来跟踪代码更改，使用自动化测试工具来确保代码质量，以及使用项目管理工具来跟踪任务和进度。")])]),v._v(" "),_("p",[v._v("至于前端开发的,我主要做了这些：")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("设计和构建用户界面：")]),v._v("前端开发的核心是创建吸引用户并与用户交互的界面。这包括使用HTML、CSS和JavaScript来创建和设计网页和应用程序。")]),v._v(" "),_("li",[_("code",[v._v("实现交互和动态功能：")]),v._v("前端开发还包括使用JavaScript和相关技术（如Ajax、React、Vue等）来实现网页和应用程序的交互和动态功能。")]),v._v(" "),_("li",[_("code",[v._v("优化性能：")]),v._v("前端开发人员需要关注网页和应用程序的性能，确保它们加载迅速、响应迅速，并在各种设备和浏览器上都能良好运行。")]),v._v(" "),_("li",[_("code",[v._v("确保兼容性和可访问性：")]),v._v("前端开发人员需要确保他们的代码在各种浏览器和设备上都能正常工作，并考虑到用户的可访问性需求。")]),v._v(" "),_("li",[_("code",[v._v("Code Reivew")]),v._v("：根据代码规范，保证代码质量，维持代码优雅整洁，高可维护性。")]),v._v(" "),_("li",[_("code",[v._v("与后端开发人员协作：")]),v._v("前端开发人员需要与后端开发人员紧密协作，确保前后端之间的数据交换和交互能够顺畅进行。")])]),v._v(" "),_("h3",{attrs:{id:"_11-nodejs用过吗-请说下底层实现"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_11-nodejs用过吗-请说下底层实现"}},[v._v("#")]),v._v(" 11.Nodejs用过吗？请说下底层实现")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("该题回答只提到"),_("code",[v._v("NODEJS使用谷歌V8 JavaScript引擎来执行JavaScript代码")]),v._v(", 深入问就不知道了。\n后查询资料得知Node.js的底层实现主要包括以下几个部分：")])]),v._v(" "),_("li",[_("p",[_("code",[v._v("V8引擎：")]),v._v("Node.js使用Google的V8 JavaScript引擎来执行JavaScript代码。V8是一个高性能的JavaScript引擎，它将JavaScript代码编译成机器码并在本地执行，从而提供了快速和高效的执行速度。")])]),v._v(" "),_("li",[_("p",[_("code",[v._v("事件循环（Event Loop）：")]),v._v("Node.js采用非阻塞I/O模型，使用事件循环来处理异步操作。事件循环监听各种事件，如网络请求、文件操作等，并在事件发生时调用相应的回调函数。这种模型使得Node.js能够高效地处理高并发请求，并且不会因为单个阻塞操作而导致整个应用程序挂起。")])]),v._v(" "),_("li",[_("p",[_("code",[v._v("libuv库：")]),v._v("Node.js使用libuv库来处理底层的异步I/O操作。libuv是一个跨平台的C库，提供了对多种操作系统原生异步I/O的支持，如epoll（Linux）、kqueue（BSD）、IOCP（Windows）等。它封装了不同操作系统的底层异步机制，使得Node.js能够在不同的平台上实现一致的异步行为。")])]),v._v(" "),_("li",[_("p",[_("code",[v._v("Node.js核心模块：")]),v._v("Node.js还提供了一些核心模块，如fs（文件系统）、http（HTTP服务器和客户端）、net（网络套接字）等，这些模块封装了常见的底层功能，使得开发人员能够更方便地使用Node.js进行开发。")])])]),v._v(" "),_("p",[v._v("总的来说，Node.js的底层实现基于V8引擎、事件循环、libuv库和核心模块等组件，通过提供非阻塞I/O和异步操作的能力，使得JavaScript能够在服务器端高效运行，并且能够快速响应高并发请求。")]),v._v(" "),_("h3",{attrs:{id:"_12-你了解事件循环机制吗"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_12-你了解事件循环机制吗"}},[v._v("#")]),v._v(" 12.你了解事件循环机制吗?")]),v._v(" "),_("blockquote",[_("blockquote",[_("p",[v._v("该题由于知识面没掌握到，直接说不清楚。后查阅资料了解到：")])])]),v._v(" "),_("p",[v._v("JavaScript的事件循环（Event Loop）是Node.js和浏览器环境中JavaScript执行的核心机制。它负责处理异步操作，如定时器、网络请求、用户交互等，并决定何时调用相应的回调函数。")]),v._v(" "),_("p",[v._v("以下是JS事件循环的基本机制：")]),v._v(" "),_("ul",[_("li",[_("p",[_("code",[v._v("调用栈（Call Stack）：")]),v._v("JavaScript引擎有一个单一的线程来执行代码，这个线程有一个调用栈来跟踪当前正在执行的函数。当函数被调用时，它会被推入调用栈中，当函数执行完毕并返回结果时，它会被从调用栈中弹出。")])]),v._v(" "),_("li",[_("p",[_("code",[v._v("异步队列（Async Queue）：")]),v._v("当异步操作（如setTimeout、setInterval、网络请求等）被触发时，它们的回调函数会被放入一个异步队列中等待执行。这些异步操作通常由JavaScript引擎以外的其他线程（如浏览器的Web API线程）处理。")])]),v._v(" "),_("li",[_("p",[_("code",[v._v("事件循环：")]),v._v("事件循环是JavaScript引擎中的一个持续运行的过程，它不断地检查调用栈是否为空。如果调用栈为空，说明当前没有正在执行的函数，那么事件循环会从异步队列中取出一个事件（通常是回调函数）并放入调用栈中执行。这个过程会一直重复，形成一个循环。")])]),v._v(" "),_("li",[_("p",[_("code",[v._v("微任务队列（Microtask Queue）：")]),v._v("除了异步队列，还有一个微任务队列。微任务通常是由Promise、MutationObserver等产生的。当一个微任务被触发时，它会被立即放入微任务队列中，在当前调用栈清空之后、下一个宏任务（来自异步队列）执行之前，事件循环会先检查并执行微任务队列中的所有任务。")])]),v._v(" "),_("li",[_("p",[_("code",[v._v("执行顺序：")]),v._v("事件循环的执行顺序可以总结为：执行一个宏任务（来自调用栈或异步队列）；执行所有微任务（来自微任务队列）；如果异步队列中还有宏任务，则取出下一个宏任务执行；重复以上步骤。")])]),v._v(" "),_("li",[_("p",[_("code",[v._v("终止条件：")]),v._v("事件循环会一直运行，除非调用栈和微任务队列都为空，且异步队列中没有更多的任务可以处理。在这种情况下，事件循环会停止，JavaScript引擎会等待下一个事件（如用户交互、网络请求等）来重新启动事件循环。")])])]),v._v(" "),_("p",[v._v("这种机制允许JavaScript在单线程环境中高效地处理异步操作，同时保持代码的响应性和可预测性。通过合理地使用异步编程和Promise等技术，可以编写出高效且易于维护的JavaScript代码。")]),v._v(" "),_("h3",{attrs:{id:"_13-你有什么要问的问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_13-你有什么要问的问题"}},[v._v("#")]),v._v(" 13.你有什么要问的问题")]),v._v(" "),_("p",[v._v("问了对该职位的期望，团队的状况，公司相关业务情况等")]),v._v(" "),_("h3",{attrs:{id:"总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[v._v("#")]),v._v(" 总结")]),v._v(" "),_("p",[v._v("基础知识点、基本原理方面掌握比较到位，回答上也比较顺心，但开发未使用到的技术点，显得比较不自信，回答结巴或者没有头绪。")])])}),[],!1,null,null,null);_.default=a.exports}}]);